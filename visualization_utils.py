# visualization_utils.py

import open3d as o3d
import numpy as np
import matplotlib.pyplot as plt
import os

# Assuming config.py is in the same directory or accessible
try:
    import config
except ImportError:
    print("Warning: config.py not found. Using fallback default values for visualization parameters.")
    class FallbackConfig:
        NUM_CLASSES = 20
        POINT_DIM = 3 # For safety in case of empty arrays
    config = FallbackConfig()

def get_label_colors(num_classes=None):
    """
    Generates a list of distinct RGB colors for labeling.
    """
    if num_classes is None:
        num_classes = config.NUM_CLASSES if hasattr(config, 'NUM_CLASSES') else 20
    
    # Use a matplotlib colormap that provides distinct colors
    # 'tab20' is good for up to 20 classes. For more, consider 'tab20b', 'tab20c' or custom logic.
    if num_classes <= 20:
        cmap = plt.get_cmap("tab20")
        colors = [cmap(i)[:3] for i in np.linspace(0, 1, num_classes)]
    else: # Fallback for more than 20 classes, colors might not be very distinct
        cmap = plt.get_cmap("hsv") # HSV provides a wider range of hues
        colors = [cmap(i)[:3] for i in np.linspace(0, 1, num_classes)]
    return np.array(colors)

def visualize_scan_completion(
    scan_data,                   # Dictionary from data_utils.preprocess_scan
    generated_occluded_points_np, # NumPy array of generated points for the occluded region
    target_semantic_guidance_occ_for_coloring=None, # Optional: [N_occ_gen, NUM_CLASSES] for coloring generated part
    show_window=True
):
    """
    Visualizes the original, incomplete, and completed point clouds for a single scan.

    Args:
        scan_data (dict): Processed data for a single scan, including:
            'points_orig' (np.ndarray): Original complete point cloud.
            'labels_orig' (np.ndarray): Original labels for the complete point cloud.
            'occlusion_mask' (np.ndarray): Boolean mask for occluded points.
            'occlusion_center' (np.ndarray, optional): Center of the occlusion box.
            'occlusion_size' (np.ndarray, optional): Size of the occlusion box.
            'scan_filepath' (str, optional): Path to the original scan file for title.
        generated_occluded_points_np (np.ndarray): Points generated by the model for the occluded region.
        target_semantic_guidance_occ_for_coloring (np.ndarray, optional): 
            One-hot encoded target semantic labels for the generated points, used for coloring.
            If None, generated points get a default color.
        show_window (bool): Whether to open the Open3D visualization window.
    """
    if not scan_data:
        print("Error in visualize_scan_completion: scan_data is None or empty.")
        return

    points_orig_np = scan_data.get('points_orig')
    labels_orig_np = scan_data.get('labels_orig')
    occlusion_mask_np = scan_data.get('occlusion_mask')
    occlusion_center_np = scan_data.get('occlusion_center')
    occlusion_size_np = scan_data.get('occlusion_size')
    scan_filename = os.path.basename(scan_data.get('scan_filepath', "Unknown Scan"))

    if points_orig_np is None or labels_orig_np is None or occlusion_mask_np is None:
        print("Error: Missing essential data (points, labels, or occlusion mask) in scan_data.")
        return

    num_classes_val = config.NUM_CLASSES if hasattr(config, 'NUM_CLASSES') else 20
    label_colors = get_label_colors(num_classes_val)

    # 1. Original Point Cloud (colored by ground truth labels)
    pcd_original = o3d.geometry.PointCloud()
    pcd_original.points = o3d.utility.Vector3dVector(points_orig_np)
    original_colors_rgb = label_colors[labels_orig_np.astype(int) % num_classes_val]
    pcd_original.colors = o3d.utility.Vector3dVector(original_colors_rgb)

    # 2. Incomplete Point Cloud (Visible Part Only, colored by GT labels)
    points_vis_np = points_orig_np[~occlusion_mask_np]
    labels_vis_np = labels_orig_np[~occlusion_mask_np]
    
    pcd_incomplete = o3d.geometry.PointCloud()
    if points_vis_np.shape[0] > 0:
        pcd_incomplete.points = o3d.utility.Vector3dVector(points_vis_np)
        incomplete_colors_rgb = label_colors[labels_vis_np.astype(int) % num_classes_val]
        pcd_incomplete.colors = o3d.utility.Vector3dVector(incomplete_colors_rgb)
    else: # Handle case where all points are occluded (unlikely with typical mask generation)
        pcd_incomplete.points = o3d.utility.Vector3dVector(np.empty((0,3)))


    # 3. Generated Occluded Part
    pcd_generated_occ = o3d.geometry.PointCloud()
    if generated_occluded_points_np is not None and generated_occluded_points_np.shape[0] > 0:
        pcd_generated_occ.points = o3d.utility.Vector3dVector(generated_occluded_points_np)
        if target_semantic_guidance_occ_for_coloring is not None and \
           target_semantic_guidance_occ_for_coloring.shape[0] == generated_occluded_points_np.shape[0]:
            try:
                gen_labels_idx = np.argmax(target_semantic_guidance_occ_for_coloring, axis=1)
                generated_colors_rgb = label_colors[gen_labels_idx.astype(int) % num_classes_val]
                pcd_generated_occ.colors = o3d.utility.Vector3dVector(generated_colors_rgb)
            except Exception as e:
                print(f"Warning: Could not color generated points by semantic guidance: {e}. Using default color.")
                pcd_generated_occ.paint_uniform_color([0, 1, 0]) # Default: Green
        else:
            pcd_generated_occ.paint_uniform_color([0, 1, 0]) # Default: Green
    else:
        pcd_generated_occ.points = o3d.utility.Vector3dVector(np.empty((0,3)))


    # 4. Final Completed Cloud (Visible + Generated)
    pcd_final_completed = o3d.geometry.PointCloud()
    final_points_list = []
    final_colors_list = []

    if points_vis_np.shape[0] > 0:
        final_points_list.append(points_vis_np)
        final_colors_list.append(incomplete_colors_rgb)
    
    if generated_occluded_points_np is not None and generated_occluded_points_np.shape[0] > 0:
        final_points_list.append(generated_occluded_points_np)
        if pcd_generated_occ.has_colors():
            final_colors_list.append(np.asarray(pcd_generated_occ.colors))
        else: # Should not happen if colored above, but as fallback
            final_colors_list.append(np.tile([0,1,0], (generated_occluded_points_np.shape[0],1)))

    if final_points_list:
        final_completed_cloud_np = np.vstack(final_points_list)
        final_colors_np = np.vstack(final_colors_list)
        pcd_final_completed.points = o3d.utility.Vector3dVector(final_completed_cloud_np)
        pcd_final_completed.colors = o3d.utility.Vector3dVector(final_colors_np)
    else:
        pcd_final_completed.points = o3d.utility.Vector3dVector(np.empty((0,3)))


    # Create a wireframe box for the occlusion area
    geometries_to_draw = []
    if occlusion_center_np is not None and occlusion_size_np is not None:
        min_b = occlusion_center_np - occlusion_size_np / 2
        max_b = occlusion_center_np + occlusion_size_np / 2
        # Ensure min_b < max_b for AxisAlignedBoundingBox
        if np.any(min_b >= max_b):
             print(f"Warning: Occlusion box min_bound {min_b} is not strictly less than max_bound {max_b}. Adjusting.")
             # Swap if any dimension is inverted, or add small epsilon if equal
             for i in range(3):
                 if min_b[i] >= max_b[i]:
                     max_b[i] = min_b[i] + 0.1 # Ensure max_b > min_b

        try:
            occlusion_bbox = o3d.geometry.AxisAlignedBoundingBox(min_bound=min_b, max_bound=max_b)
            box_lines = o3d.geometry.LineSet.create_from_axis_aligned_bounding_box(occlusion_bbox)
            box_lines.paint_uniform_color([0, 0, 1])  # Blue box
            geometries_to_draw.append(box_lines)
        except Exception as e:
            print(f"Could not create occlusion box visualization: {e}")
            print(f"Occlusion params: center={occlusion_center_np}, size={occlusion_size_np}")
            print(f"Calculated min_b={min_b}, max_b={max_b}")


    # Shift point clouds for side-by-side visualization
    # Calculate shift based on the original point cloud's extent
    if points_orig_np.shape[0] > 0:
        x_extent = np.ptp(points_orig_np[:, 0]) if points_orig_np.shape[0] > 0 else 50
        pcd_incomplete.translate((x_extent * 1.2, 0, 0))
        pcd_final_completed.translate((x_extent * 2.4, 0, 0))
        # Also translate the generated part if shown separately (optional)
        # pcd_generated_occ.translate((x_extent * 2.4, 0, 0)) # If showing generated part at same pos as final
    else: # Fallback shift if original points are empty
        pcd_incomplete.translate((50,0,0))
        pcd_final_completed.translate((100,0,0))


    geometries_to_draw.insert(0, pcd_original) # Add original first
    geometries_to_draw.append(pcd_incomplete)
    geometries_to_draw.append(pcd_final_completed)
    # Optionally, show the generated part separately:
    # pcd_generated_occ_shifted = o3d.geometry.PointCloud(pcd_generated_occ) # copy
    # pcd_generated_occ_shifted.translate((x_extent * 3.6, 0, 0))
    # geometries_to_draw.append(pcd_generated_occ_shifted)


    window_title = f"Point Cloud Completion: {scan_filename}"
    if show_window:
        print(f"\nVisualizing for scan: {scan_filename}")
        print("  Original (left, colored by GT labels)")
        print("  Incomplete (middle, visible part, colored by GT labels)")
        print("  Final Completed (right, visible + generated, colored by GT/Target labels)")
        print("  Occlusion Box (blue, on original)")
        print("Close the Open3D window to continue.")
        o3d.visualization.draw_geometries(geometries_to_draw, window_name=window_title)
    
    return geometries_to_draw # Return for potential non-blocking use or saving


if __name__ == '__main__':
    print("--- Testing visualization_utils.py ---")
    
    # This test requires config.py to be functional for NUM_CLASSES.
    # It creates dummy data for visualization.
    try:
        import config # Re-import for test
    except ImportError:
        print("Error: Cannot run test. Missing config.py.")
        exit()

    # Create dummy scan_data
    test_points_orig = np.random.rand(2000, 3) * 10
    test_labels_orig = np.random.randint(0, config.NUM_CLASSES, 2000)
    
    # Simulate an occlusion
    center = np.mean(test_points_orig, axis=0)
    size = np.array([4,4,4])
    test_occlusion_mask = (
        (test_points_orig[:, 0] > center[0] - size[0]/2) & (test_points_orig[:, 0] < center[0] + size[0]/2) &
        (test_points_orig[:, 1] > center[1] - size[1]/2) & (test_points_orig[:, 1] < center[1] + size[1]/2) &
        (test_points_orig[:, 2] > center[2] - size[2]/2) & (test_points_orig[:, 2] < center[2] + size[2]/2)
    )
    
    num_occluded_gt = test_occlusion_mask.sum()
    test_generated_points = np.random.rand(max(10, num_occluded_gt // 2), 3) * 5 + center - 2.5 # Some points in the occluded area
    
    # Dummy semantic guidance for coloring generated points
    test_target_semantic_guidance = None
    if test_generated_points.shape[0] > 0:
        test_target_semantic_guidance = np.random.rand(test_generated_points.shape[0], config.NUM_CLASSES)
        test_target_semantic_guidance = test_target_semantic_guidance / np.sum(test_target_semantic_guidance, axis=1, keepdims=True) # Normalize to look like softmax


    dummy_scan_data = {
        'points_orig': test_points_orig,
        'labels_orig': test_labels_orig,
        'occlusion_mask': test_occlusion_mask,
        'occlusion_center': center,
        'occlusion_size': size,
        'scan_filepath': "dummy_scan_001.bin"
        # Other fields like plane_dist, etc., are not strictly needed for this visualization test
    }

    print("Visualizing dummy data...")
    visualize_scan_completion(
        dummy_scan_data, 
        test_generated_points,
        target_semantic_guidance_occ_for_coloring=test_target_semantic_guidance,
        show_window=True
    )
    
    print("\n--- Finished testing visualization_utils.py ---")

